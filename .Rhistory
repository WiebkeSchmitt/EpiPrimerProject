chr<-chr[filter.by.assembly]
start<-start[filter.by.assembly]
end<-end[filter.by.assembly]
if(!is.null(strand)){
strand<-strand[filter.by.assembly]
}
if(!is.null(seqinfo)){
seqinfo<-seqinfo[filter.by.assembly]
}
}
user <- unname(Sys.info()["user"])
if (user == "shiny") {
# Set library locations
ds <- .libPaths(c("/home/users/amerg/R/x86_64-redhat-linux-gnu-library/3.3","/opt/Rlib/3.2","/usr/lib64/R/library","/usr/share/R/library"))
}
require (rtracklayer)
mySession = browserSession(browser)
genome(mySession) <- assembly
#GRanges(seqnames=NULL,ranges=NULL, strand=NULL,
#..., seqlengths=NULL, seqinfo=NULL): Creates a GRanges object.
#
#see help GRanges
#gr0 <- GRanges(seqnames = chr, IRanges(start = start,end = end))
#
#  if(!is.null(strand)){strand(gr0)<-strand}
#
#  if(!is.null(seqinfo)){
#    to.seq.info <- Seqinfo(seqinfo)
#    #seqinfo(gr0) <- merge(seqinfo(gr0), to.seq.info)
#    seqinfo(gr0)<-merge(seqinfo(gr0), to.seq.info)
#    #seqlevels(gr0) <- seqlevels(to.seq.info)
#  }
myquer<-ucscTableQuery(mySession,track,GRangesForUCSCGnome(assembly,chr,IRanges(start,end,names=seqinfo)))
tableName(myquer)<- paste(table)
#genebrowser.info <- getTable(session = mySession, trackName = track, tableName = table,)
genebrowser.info <- getTable(myquer)
return(genebrowser.info)
}# end of ucsc function
#############  Initialize settings object  #######################################################
# #create main .html file
# log("Create HTML scaffolds...")
# if(primer.type=="hp_bisulfite" | primer.type=="hp_NOME" | primer.type=="hp_genomic" | primer.type=="hp_CLEVER"){
# links<-c(paste("html_",analysis.id,"/settings_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/bedfile_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/RestrictionEnzymesAndLinkerInfo_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/Hairpinizer_Results_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/summary_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/primer_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/primer_",analysis.id,"_toplist.html",sep=""))
# labs<-c("Settings","InputFile","Restriction Enzymes & Linkers","Hairpinizer Results","Summary","Primer","Primer_Toplist")
# }
# if(primer.type=="bisulfite" | primer.type=="NOME" | primer.type=="genomic" | primer.type=="CLEVER"){
# links<-c(paste("html_",analysis.id,"/settings_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/bedfile_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/summary_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/primer_",analysis.id,".html",sep=""),
# paste("html_",analysis.id,"/primer_",analysis.id,"_toplist.html",sep=""))
# labs<-c("Settings","InputFile","Summary","Primer","Primer_Toplist")
# }
# html.main.page(fn.links = links,labels = labs,filename = paste(path.out,"PrimerDesign_",analysis.id,".html",sep=""))
# #create overview .html file
settings<-data.frame(PARAMETERS=c("Date",
"Script_Version",
#"Name of Inputfile",
"Type of Inputfile",
"Output Path",
"Analysis ID",
"Primer Design Type",
"Primer Design Mode",
"Analyzed DNA Strands",
"Minimum Length of Primers",
"Maximum Length of Primers",
"Minimum Tm of Primers",
"Maximum Tm of Primers",
"Maximum Tm difference",
"Remove Low Complexity Primers",
"Maximum Number of Low Complex Bins (1mers/2mers/3mers)",
"Remove 'N'containing primers",
"Minimum Length of Amplicon",
"Maximum Length of Amplicon",
"Use target columns",
"Minimum Number of GpCs in Amplicon",
"Minimum Number of CpGs in Amplicon",
paste("Minimum 'C' to 'T' conversions in primer 1",sep=""),
paste("Minimum 'G' to 'A' conversions in primer 2",sep=""),
"Primer Dimer BinSize",
"Check for Primer SNPs",
"Minimum SNPs in amplicon",
"Maximum SNPs in amplicon",
"Minimum SNPs in primer1",
"Maximum SNPs in primer1",
"Minimum SNPs in primer2",
"Maximum SNPs in primer2",
"Check for Repeats",
"Allow Repeats in Primers",
"Allow Repeats in Amplicon",
"Annotate Genes",
"Annotate CpG Islands",
"Create Toplist Table",
"Create graphics"),
SETTINGS=c(mydate,
paste(scriptID),
#paste(filename.in),
paste(input.type),
paste(path.out),
paste(analysis.id),
paste(primer.type),
paste(mode),
paste(strand),
paste(min.length.primer),
paste(max.length.primer),
paste(min.Tm.primer),
paste(max.Tm.primer),
paste(max.Tm.difference.primer),
paste(low.complexity.primer.removal),
paste(max.bins.low.complexity),
paste(remove.primers.with.n),
paste(min.length.amplicon),
paste(max.length.amplicon),
paste(use.target.columns),
paste(min.number.gc.amplicon),
paste(min.number.cg.amplicon),
paste(min.C2T.primer1),
paste(min.G2A.primer2),
paste(primer.align.binsize),
paste(check4snps),
paste(min.snps.amplicon),
paste(max.snps.amplicon),
paste(min.snps.primer1),
paste(max.snps.primer1),
paste(min.snps.primer2),
paste(max.snps.primer2),
paste(check4repeats),
paste(allow.repeats.in.primers),
paste(allow.repeats.in.amplicon),
paste(annotate.genes),
paste(annotate.cpg.islands),
paste(create.toplist),
paste(create.graphics)))
if(primer.type=="hp_bisulfite" | primer.type=="hp_NOME" | primer.type=="hp_genomic" | primer.type=="hp_CLEVER"){
settings<-rbind(settings,
data.frame(PARAMETERS=c("hp.filename",
"hp.length.min",
"hp.length.max"),
SETTINGS=c(hp.filename,
hp.length.min,
hp.length.max)))
}
if(primer.type=="hp_genomic" | primer.type=="genomic"){
settings<-rbind(settings,
data.frame(PARAMETERS="input.chop.size",
SETTINGS=chop.size))
}
write.table(settings,file=paste(path.wd,"settings_",analysis.id,".txt",sep=""),
col.names=T,row.names=F,sep="\t",dec=".",quote=F)
log("Done.")
#############  Import data in regions format  ###################################
#start data import
log("Module: Data Import.")
if (input.type=="regions"){
log("Fetch sequences from UCSC...")
#iregs <- filetable.in #iregs<-read.table(filename.in,header=T,sep="\t",dec=".")
iregs<- table.in
def.cols<-c("chr","start","end","assembly","sequenceID","sequence.length","sequence.adress","sequence")
nregs<-nrow(iregs)#number of input regions
if(nregs>maximum.input.regions){
stop(paste("Too many input regions [max: ",maximum.input.regions,"]",sep=""))
}
if(!all(grepl("chr",iregs$chr))){
stop(paste("'chr' column in input file is not in the correct format ('chr'[chr])",sep=""))
}
iregchr<-as.character(iregs$chr)
bed<-data.frame(chr=rep(NA,nregs),start=rep(NA,nregs),end=rep(NA,nregs),
assembly=rep(NA,nregs),
sequenceID=rep(NA,nregs),sequence.length=rep(NA,nregs),
sequence.adress=rep(NA,nregs),sequence=rep(NA,nregs))
bed$chr<-as.character(bed$chr)
bed$chr<-iregchr
bed$start<-as.numeric(bed$start)
bed$end<-as.numeric(bed$end)
undef.cols<-colnames(iregs)[!colnames(iregs) %in% def.cols]
bed[,undef.cols]<-NA
#for each entry in input.file retrieve dna seq
for (ir in 1:nregs){
dna<-getDNA(iregs[ir,"chr"],iregs[ir,"start"],iregs[ir,"end"],iregs[ir,"assembly"])
sid<-iregs[ir,"sequenceID"]
if(is.na(sid)|sid==""){
sid<-paste(c(iregs[ir,"assembly"],"_",iregs[ir,"chr"],"_",iregs[ir,"start"],"_",iregs[ir,"end"]),sep="")
}
adr<-paste(c(as.character(iregs[ir,"chr"]),"_",iregs[ir,"start"],"_",iregs[ir,"end"]),sep="")
bed[ir,c("start",
"end",
"assembly",
"sequenceID",
"sequence.length",
"sequence.adress",
"sequence")]<-c(iregs[ir,"start"],iregs[ir,"end"],paste(iregs[ir,"assembly"]),
paste(iregs[ir,"species"]),paste(sid),nchar(dna),paste(adr,collapse=""),
dna)
bed[ir,undef.cols]<-iregs[ir,undef.cols]
}
if(any(nchar(bed$sequence)) > maximum.input.region.length.bp){
stop(paste(" one or more input regions are too large [max: ",maximum.input.region.length.bp,"]",sep=""))
}
#remove entries with no sequence retrieved
bad.seq.f<-bed$sequence.length<1
bad.out<-bed[bad.seq.f,]
if(nrow(bad.out)>0){
write.table(bad.out,file=paste(path.sequences,analysis.id,"EntriesWithNoSequences.txt",sep=""),sep="\t",dec=".",
col.names=T,row.names=F)
}
bed<-bed[!bad.seq.f,]
##########  Input sequence characterization #####################################
#perform input sequence characterization
log("Start characterization of input sequences...")
seq.ana.all<-list()
for (iiii in 1:nrow(bed)){
seqanai<-sequence.characterization(paste(bed[iiii,"sequence"]))
write.table(seqanai,file=paste(path.sequences,"sequence.characterization_",bed[iiii,"sequenceID"],".txt",sep=""),
sep="\t",dec=".",col.names=T,row.names = FALSE,quote=F)
seq.ana.all[[paste(bed[iiii,"sequenceID"])]]<-seqanai
}
log("Done.")
############  Retrieve snp information  ###############################################
#retrieve snp information for input sequences
if (check4snps){
supported.assemblies.snp<-c("hg18","hg19","hg38","mm9","mm10")
log("Start SNP analysis...")
if(input.type=="sequences"){
#should check biomart....
log(paste("WARNING: To check for SNPs input type must be regions."))
fileConn<-file(paste(path.warnings,"Warning.SNPcheck.data.error.txt",sep=""))
writeLines(c("WARNING: To check for SNPs input type must be regions."), fileConn)
close(fileConn)
}
if(input.type=="regions"){
assems<-paste(unique(bed[,"assembly"]))
for (iasem in 1:length(assems)){
assem<-assems[iasem]
bedia<-bed[as.character(bed$assembly)==assem,]
if(!assem %in% supported.assemblies.snp){
log(paste("...assembly [",assem, "] not supported for SNP analysis",sep=""))
next()
}
if(assem %in% supported.assemblies.snp){
snptrack<-switch(assem,
"hg18" = "snp130",
"hg19" = "snp147Common",
"hg38" = "snp150Common",
"mm9"  = "snp128",
"mm10" = "snp142Common")
snptable<-switch(assem,
"hg18" = "snp130",
"hg19" = "snp147Common",
"hg38" = "snp150Common",
"mm9"  = "snp128",
"mm10" = "snp142Common")
chrom<-paste(bedia[,"chr"])
allstarts<-as.numeric(as.character(bedia[,"start"]))
allends<-as.numeric(as.character(bedia[,"end"]))
my_snps<-ucsc.info(assembly = assem,
chr = chrom,
start = allstarts,
end = allends,
track = snptrack,
table = snptable)
my_snps$assembly<-assem
my_snps$SNP.db<-snptable
if(iasem==1){
all_my_snps<-my_snps
}#if assem
if(iasem>1){
all_my_snps<-rbind(all_my_snps,my_snps)
}#if >1
}#if assem
}#for assem
write.table(all_my_snps,file=paste(path.tracks,"#SNP.info.input.regions.txt",sep=""),
sep="\t",dec=".",col.names=T,row.names=F,quote=F)
}#if regions
}#check4snps
############  Retrieve repeat information  ############################################
#retrieve repeat information for input sequences
if (check4repeats){
supported.assemblies.snp<-c("hg18","hg19","hg38","mm9","mm10")
log("Start Repeat analysis...")
if(input.type=="sequences"){
#should check biomart....
log(paste("WARNING: To check for repeats input type must be regions."))
fileConn<-file(paste(path.warnings,"Warning.Repeatcheck.data.error.txt",sep=""))
writeLines(c("WARNING: To check for repeats input type must be regions."), fileConn)
close(fileConn)
}
if(input.type=="regions"){
assems<-paste(unique(bed[,"assembly"]))
for (iasem in 1:length(assems)){
assem<-assems[iasem]
bedia<-bed[as.character(bed$assembly)==assem,]
if(!assem %in% supported.assemblies.snp){
log(paste("...assembly [",assem, "] not supported for repeat analysis",sep=""))
next()
}
if(assem %in% supported.assemblies.snp){
rpttrack<-switch(assem,
"hg18" = "rmsk",
"hg19" = "rmsk",
"hg38" = "rmsk",
"mm9"  = "rmsk",
"mm10" = "rmsk")
rpttable<-switch(assem,
"hg18" = "rmsk",
"hg19" = "rmsk",
"hg38" = "rmsk",
"mm9"  = "rmsk",
"mm10" = "rmsk")
chrom<-paste(bedia[,"chr"])
allstarts<-as.numeric(as.character(bedia[,"start"]))
allends<-as.numeric(as.character(bedia[,"end"]))
my_repeats<-ucsc.info(assembly = assem,
chr = chrom,
start = allstarts,
end = allends,
track = rpttrack,
table = rpttable)
if(nrow(my_repeats)>0){
my_repeats$assembly<-assem
my_repeats$repeat.db<-rpttable
}
if(nrow(my_repeats)>0){
m_repeats<-data.frame(assembly=assem,chr=chrom,start=NA,end=NA,track=NA,table=NA)
}
if(iasem==1){
all_my_repeats<-my_repeats
}#if assem
if(iasem>1){
all_my_repeats<-rbind(all_my_repeats,my_repeats)
}#if >1
}#if assem
}#for assem
write.table(all_my_repeats,file=paste(path.tracks,"#repeat.info.input.regions.txt",sep=""),
sep="\t",dec=".",col.names=T,row.names=F,quote=F)
}#if regions
}#check4repeats
###########  Retrieve gene information  ###############################################
#retrieve gene information for input sequences
if (annotate.genes){
supported.assemblies.snp<-c("hg18","hg19","hg38","mm9","mm10")
log("Start Gene annotation analysis...")
if(input.type=="sequences"){
#should check biomart....
log(paste("WARNING: To check for gene annotations input type must be regions."))
fileConn<-file(paste(path.warnings,"Warning.GeneAnnotationcheck.data.error.txt",sep=""))
writeLines(c("WARNING: To check for Gene Annotation input type must be regions."), fileConn)
close(fileConn)
}
if(input.type=="regions"){
assems<-paste(unique(bed[,"assembly"]))
for (iasem in 1:length(assems)){
assem<-assems[iasem]
bedia<-bed[as.character(bed$assembly)==assem,]
if(!assem %in% supported.assemblies.snp){
log(paste("...assembly [",assem, "] not supported for gene annotation analysis",sep=""))
next()
}
if(assem %in% supported.assemblies.snp){
genetrack<-switch(assem,
"hg18" = "refGene",
"hg19" = "refSeqComposite",
"hg38" = "refSeqComposite", #refGene
"mm9"  = "refGene",
"mm10" = "refSeqComposite")
genetable<-switch(assem,
"hg18" = "refGene",
"hg19" = "refGene",
"hg38" = "refGene", #refGene
"mm9"  = "refGene",
"mm10" = "refGene")
chrom<-paste(bedia[,"chr"])
allstarts<-as.numeric(as.character(bedia[,"start"]))
allends<-as.numeric(as.character(bedia[,"end"]))
my_genes<-ucsc.info(assembly = assem,
chr = chrom,
start = allstarts,
end = allends,
track = genetrack,
table = genetable)
my_genes$assembly<-assem
my_genes$gene.db<-genetable
if(iasem==1){
all_my_genes<-my_genes
}#if assem
if(iasem>1){
all_my_genes<-rbind(all_my_genes,my_genes)
}#if >1
}#if assem
}#for assem
write.table(all_my_genes,file=paste(path.tracks,"#gene.info.input.regions.txt",sep=""),
sep="\t",dec=".",col.names=T,row.names=F,quote=F)
}#if regions
}#annotate.genes
###########  Retrieve CpG island information  #########################################
#retrieve cpg island information for input sequences
if (annotate.genes){
supported.assemblies.snp<-c("hg18","hg19","hg38","mm9","mm10")
log("Start CpG Island annotation analysis...")
if(input.type=="sequences"){
#should check biomart....
log(paste("WARNING: To check for CpG island annotations input type must be regions."))
fileConn<-file(paste(path.warnings,"Warning.CpGIcheck.data.error.txt",sep=""))
writeLines(c("WARNING: To check for CpG Islands input type must be regions."), fileConn)
close(fileConn)
}
if(input.type=="regions"){
assems<-paste(unique(bed[,"assembly"]))
for (iasem in 1:length(assems)){
assem<-assems[iasem]
bedia<-bed[as.character(bed$assembly)==assem,]
if(!assem %in% supported.assemblies.snp){
log(paste("...assembly [",assem, "] not supported for cpg island annotation analysis",sep=""))
next()
}
if(assem %in% supported.assemblies.snp){
cpgitrack<-switch(assem,
"hg18" = "cpgIslandExt",
"hg19" = "cpgIslandExt",
"hg38" = "cpgIslandExt",
"mm9"  = "cpgIslandExt",
"mm10" = "cpgIslandExt")
cpgitable<-switch(assem,
"hg18" = "cpgIslandExt",
"hg19" = "cpgIslandExt",
"hg38" = "cpgIslandExt",
"mm9"  = "cpgIslandExt",
"mm10" = "cpgIslandExt")
chrom<-paste(bedia[,"chr"])
allstarts<-as.numeric(as.character(bedia[,"start"]))
allends<-as.numeric(as.character(bedia[,"end"]))
my_cpgi<-ucsc.info(assembly = assem,
chr = chrom,
start = allstarts,
end = allends,
track = cpgitrack,
table = cpgitable)
if(nrow(my_cpgi)>0){
my_cpgi$assembly<-assem
my_cpgi$cpgi.db<-cpgitable
}
if(iasem==1){
all_my_cpgis<-my_cpgi
}#if assem
if(iasem>1){
all_my_cpgis<-rbind(all_my_cpgis,my_cpgi)
}#if >1
}#if assem
}#for assem
write.table(all_my_cpgis,file=paste(path.tracks,"#cpgi.info.input.regions.txt",sep=""),
sep="\t",dec=".",col.names=T,row.names=F,quote=F)
}#if regions
}#annotate.cpgi
########  Finalize region import  #####################################################
if(primer.type == "bisulfite" | primer.type == "hp_bisulfite"){
bed$sequence.converted<-sapply(bed$sequence,bisulfite.conversion,strand=strand)
}
if(primer.type == "NOME" | primer.type == "hp_NOME"){
bed$sequence.converted<-sapply(bed$sequence,gcCon,strand=strand)
}
if(primer.type == "genomic" | primer.type == "hp_genomic" | primer.type == "CLEVER" | primer.type == "hp_CLEVER"){
bed$sequence.converted<-bed$sequence
}
hp.initial.input.type<-input.type
bed$Index<-1:nrow(bed)
write.table(bed,file=paste(path.sequences,analysis.id,"_PrimerDesign_InputSequences.txt",sep=""),sep="\t",dec=".",
col.names=TRUE,row.names=FALSE,quote=F)
html.report(filenames =  paste(path.sequences,analysis.id,"_PrimerDesign_InputSequences.txt",sep=""),
filename.out = paste(path.html,"bedfile_",analysis.id,".html",sep=""),txt.header = TRUE,txt.sep = "\t")
log("Done.")
}
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
shiny::runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
runApp('epiprimer/epiprimer_Wiebke')
